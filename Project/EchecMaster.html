<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<title>Échecs Avancé — Jarvis Edition (V8.0 - Néon Unique & Log Défilant)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  /* ---------------------------------------------------- */
  /* --- I. VARIABLES ET THÈMES CSS (V8.0 - THÈME NÉON UNIQUE) --- */
  /* ---------------------------------------------------- */

  :root{
    /* Thème Néon Rendu Unique et Principal */
    --bg:#0b0b12; 
    --panel:#07070a; 
    --accent:#ff00c8; /* Magenta Vif */
    --light-square:#101020; /* Cases claires sombres */
    --dark-square:#05050a; /* Cases foncées très sombres */
    --text:#e6faff; 
    --muted:#9b9bff; 
    --highlight: rgba(255,0,200,0.12); /* Surlignage Néon */

    /* Dimensions */
    --size: 72px; 
    --piece-font-size: 52px; 
    --piece-stroke-width: 2.0px; /* Lignes des pièces légèrement plus fines */ 

    /* Pièces Blanches (Rose Fluorescent) */
    --piece-white-color: #e6eef6; /* Remplissage Clair (Aspect opaque/translucide) */        
    --piece-white-contour: #ff00c8; /* Contour Magenta/Rose */      
    --piece-white-shadow: 0 0 8px #ff00c8; /* Lueur rose */
    
    /* Pièces Noires (Aspect Pièces Blanches, Couleurs Cyan) */
    --piece-black-color: #a6d5ff; /* Remplissage clair bleuté (Donne du corps au pion) */        
    --piece-black-contour: #00ffff; /* Contour Cyan Vif/Bleu Fluorescent */     
    --piece-black-shadow: 0 0 8px #00ffff; /* Lueur bleue pour l'harmonie et l'aspect fluo */
  }

  /* ---------------------------------------------------- */
  /* --- II. STYLES GÉNÉRAUX ET UX --- */
  /* ---------------------------------------------------- */
  html,body{
    height:100%; margin:0; font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
    background: var(--bg); color:var(--text); -webkit-font-smoothing:antialiased;
    transition: background-color 300ms, color 300ms;
  }

  main{
    max-width:1200px; margin:20px auto; display:grid;
    grid-template-columns: 1fr 360px;
    gap:20px; padding:20px;
  }

  header{
    grid-column:1/-1; display:flex; justify-content:space-between;
    align-items:center; gap:20px; margin-bottom:6px;
  }
  
  h1{ margin:0; font-weight:600; font-size:18px; color:var(--accent); letter-spacing:0.6px; }

  .controls, aside > div {
    background: var(--panel);
    padding: 10px;
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.05);
    margin-bottom: 15px; 
  }
  
  .controls{
    display: flex; gap: 10px; align-items: center; flex-wrap: wrap; 
  }

  button, input[type="text"], select {
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 14px;
    border: 1px solid var(--muted);
    background: var(--bg);
    color: var(--text);
    transition: background-color 200ms, border-color 200ms;
    cursor: pointer;
  }
  
  button.primary { background: var(--accent); color: var(--panel); border-color: var(--accent); font-weight: 600; }
  button.ghost { background: transparent; color: var(--accent); border-color: var(--accent); }
  button:hover:not(:disabled){ opacity: 0.85; }

  select {
    appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'%3E%3Cpath fill='%239fb0c8' d='M5 8l5 5 5-5z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    background-size: 14px;
  }

  .panel-title{ color: var(--accent); font-weight: 600; margin-bottom: 8px; font-size: 15px; }
  .move-line { font-size: 14px; padding: 3px 0; border-bottom: 1px dashed rgba(255, 255, 255, 0.05); }
  .muted{ color:var(--muted); font-size:13px; }

  /* --- LOG DES COUPS (NOUVEAUTÉ V8.0) --- */
  #movesLog {
    max-height: 250px; 
    overflow-y: auto; 
    padding-right: 8px; 
    /* Ces deux lignes forcent l'empilement du texte par le bas pour simuler un log */
    direction: rtl; 
    text-align: left;
  }
  #movesLog > div {
    /* Rétablit la lecture normale du texte */
    direction: ltr; 
  }
  
  /* ---------------------------------------------------- */
  /* --- III. STYLES DE L'ÉCHIQUIER ET DES PIÈCES --- */
  /* ---------------------------------------------------- */

  .board-wrap{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02);
    display:inline-block;
    min-width: calc(8 * var(--size) + 40px + 24px); 
  }

  .coords {
    display:grid; grid-template-columns: 20px repeat(8, var(--size)) 20px;
    grid-template-rows: 20px repeat(8, var(--size)) 20px;
    gap:0; position:relative;
  }

  .board-grid{
    grid-column:2/10; grid-row:2/10;
    display:grid; grid-template-columns: repeat(8, var(--size));
    grid-template-rows: repeat(8, var(--size));
    border-radius:6px; overflow:visible; position:relative;
  }

  .square {
    width:var(--size); height:var(--size);
    display:flex; align-items:center; justify-content:center;
    font-size:16px; user-select:none; position:relative; 
  }

  .square.light{ background:var(--light-square); } 
  .square.dark{ background:var(--dark-square); } 
  .square.highlight { box-shadow: inset 0 0 0 4px var(--highlight); }
  .square.last-move { outline: 3px solid rgba(255,255,255,0.1); } 

  /* Pièces (Netteté Harmonisée V7.6) */
  .piece {
    position:absolute; 
    font-size:var(--piece-font-size); 
    font-family: 'Times New Roman', Georgia, serif; 
    transition: transform 220ms cubic-bezier(.2,.9,.2,1), opacity 120ms;
    pointer-events:none;
    -webkit-text-stroke-width: var(--piece-stroke-width);
    -webkit-font-smoothing: antialiased;
    font-weight: 900; 
  }

  /* Pièces Blanches (Netteté / Rose Fluorescent) */
  .piece[data-p^="R"], .piece[data-p^="N"], .piece[data-p^="B"], .piece[data-p^="Q"], .piece[data-p^="K"], .piece[data-p^="P"] {
      color: var(--piece-white-color) !important; 
      -webkit-text-stroke-color: var(--piece-white-contour);
      text-shadow: var(--piece-white-shadow); 
  }

  /* Pièces Noires (Netteté / Bleu Fluorescent V7.6) */
  .piece[data-p^="r"], .piece[data-p^="n"], .piece[data-p^="b"], .piece[data-p^="q"], .piece[data-p^="k"], .piece[data-p^="p"] {
      color: var(--piece-black-color) !important; 
      -webkit-text-stroke-color: var(--piece-black-contour);
      text-shadow: var(--piece-black-shadow); 
  }

  /* Style de la modale de promotion */
  .modal{ display:none; position:fixed; z-index:100; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.6); }
  .modal .box{ background-color:var(--panel); margin:15% auto; padding:20px; border:1px solid var(--accent); width:80%; max-width:300px; border-radius:8px; }
  .prom-options button { font-size: 32px; padding: 10px; margin: 5px; }
  
  /* Indicateur de succès pour la sauvegarde */
  .save-feedback {
    background: #4CAF50; color: white; padding: 5px 10px;
    border-radius: 4px; font-size: 12px; margin-top: 5px;
    opacity: 0; transition: opacity 0.5s;
  }
  .save-feedback.show { opacity: 1; }

  @media(max-width:980px){
    main{ grid-template-columns: 1fr; }
    aside{ order:2; }
    .board-wrap{ margin:0 auto; display:block; }
  }
</style>
</head>
<body class="theme-neon"> <main>

  <header>
    <div>
      <h1>Échecs Avancé — Jarvis Edition (V8.0 - Néon Unique)</h1>
      <div class="small muted">Jeu à distance par coordonnées, sauvegarde automatique.</div>
    </div>

    <div class="controls">
      <label class="small muted">Orientation</label>
      <select id="orientSelect">
        <option value="white">Blancs en bas</option>
        <option value="black">Noirs en bas</option>
      </select>

      <button id="undoBtn" class="ghost">Annuler un coup</button>
      <button id="resetBtn" class="primary">Nouvelle partie (Réinitialise la sauvegarde)</button>
    </div>
  </header>

  <section>
    <div class="board-wrap" id="boardWrap">
      <div style="display:flex; gap:8px; margin-bottom:8px;">
        <input id="moveInput" type="text" placeholder="Entrez le coup (ex: e2-e4 ou e7e8=Q)" style="flex:1" />
        <button id="sendMove" class="primary">Appliquer Coup (Notation)</button>
      </div>

      <div class="coords" id="coords">
        <div class="board-grid" id="boardGrid"></div>
      </div>

      <div style="margin-top:8px; display:flex; gap:8px;">
        <div class="status" id="gameStatus">Tour: Blancs</div>
        <div class="muted" id="captured">Capturées — Blancs: 0 | Noirs: 0</div>
      </div>
       <div id="saveFeedback" class="save-feedback"></div>
    </div>
  </section>

  <aside>
    <div>
      <div class="panel-title">Journal des coups (PGN simplifié)</div>
      <div id="movesLog"></div> </div>
    <div>
      <div class="panel-title">Options</div>
      <div style="display:flex; gap:8px;">
        <button id="exportPgn" class="ghost">Exporter PGN</button>
        <button id="flipBoard" class="ghost">Retourner l'échiquier</button>
      </div>
    </div>

    <div>
      <div class="panel-title">Sons</div>
      <div style="display:flex; gap:8px;">
        <button id="toggleSound" class="ghost">Activer/Désactiver le son</button>
      </div>
      <div class="small muted">Note: Le son peut nécessiter une première interaction (clic) pour s'activer.</div>
    </div>

    <div>
      <div class="panel-title">Règles incluses</div>
      <ul class="small muted" style="margin:6px 0 0 16px;">
        <li>Validation complète de la légalité (éviter l'échec au roi)</li>
        <li>Roque, Prise en passant et Promotion gérés</li>
        <li>Détection d'Échec et Mat</li>
      </ul>
    </div>
  </aside>

</main>

<div id="promoModal" class="modal">
  <div class="box">
    <div class="panel-title">Promotion — Choisis une pièce (Blanche)</div>
    <div class="prom-options" id="promOptions">
      <button data-piece="Q">♕</button>
      <button data-piece="R">♖</button>
      <button data-piece="B">♗</button>
      <button data-piece="N">♘</button>
    </div>
  </div>
</div>

<script>
// ----------------------------------------------------
// --- IV. MOTEUR DE JEU JAVASCRIPT COMPLET (V8.0 - Thème unique et Log défilant) ---
// ----------------------------------------------------

const PIECES_UNICODE = {
  // Le pion noir ('p') utilise maintenant le même caractère que le pion blanc ('P') : '♙'
  'r':'♜','n':'♞','b':'♝','q':'♛','k':'♚','p':'♙', 
  'R':'♖','N':'♘','B':'♗','Q':'♕','K':'♔','P':'♙'
};
const STORAGE_KEY = 'chessGameSaveV3'; 

let board = []; let turn = 'w'; let castleRights = { wK:true, wQ:true, bK:true, bQ:true }; 
let enPassant = null; let halfmoveClock = 0; let fullmoveNumber = 1; 
let history = []; let capturedPieces = { w:[], b:[] };
let soundEnabled = true; let orientation = 'white'; 
let audioContext = null; 

const START_FEN = [
  ['r','n','b','q','k','b','n','r'], ['p','p','p','p','p','p','p','p'],
  ['','','','','','','',''], ['','','','','','','',''],
  ['','','','','','','',''], ['','','','','','','',''],
  ['P','P','P','P','P','P','P','P'], ['R','N','B','Q','K','B','N','R']
];

// Références DOM
const boardGrid = document.getElementById('boardGrid');
const moveInput = document.getElementById('moveInput');
const sendMoveBtn = document.getElementById('sendMove');
const movesLog = document.getElementById('movesLog');
const gameStatus = document.getElementById('gameStatus');
const promoModal = document.getElementById('promoModal');
const promOptions = document.getElementById('promOptions');
// const themeSelect = document.getElementById('themeSelect'); // SUPPRIMÉ
const orientSelect = document.getElementById('orientSelect');
const flipBoardBtn = document.getElementById('flipBoard');
const resetBtn = document.getElementById('resetBtn');
const undoBtn = document.getElementById('undoBtn');
const toggleSoundBtn = document.getElementById('toggleSound');
const capturedElem = document.getElementById('captured');
const exportPgn = document.getElementById('exportPgn');
const saveFeedback = document.getElementById('saveFeedback');


// --- UTILITIES ---
function showFeedback(message, isError = false) {
    saveFeedback.textContent = message;
    saveFeedback.className = 'save-feedback show';
    if (isError) {
        saveFeedback.style.backgroundColor = '#f44336';
    } else {
        saveFeedback.style.backgroundColor = '#4CAF50';
    }
    setTimeout(() => {
        saveFeedback.classList.remove('show');
    }, 3000);
}

// Initialisation du contexte audio lors du premier clic/action
function initAudioContext() {
    if (audioContext === null) {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.error("AudioContext non supporté ou bloqué.", e);
            audioContext = false; 
        }
    }
    if (audioContext && audioContext.state === 'running') {
        document.removeEventListener('click', initAudioContext);
    }
}
document.addEventListener('click', initAudioContext, { once: true });


function playSimple(type){ 
  if(!soundEnabled || audioContext === false) return;
  if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().catch(e => console.error("Échec de la reprise de l'AudioContext:", e));
  }
  if(!audioContext || audioContext.state !== 'running') return;
  
  try{
    const o = audioContext.createOscillator(); const g = audioContext.createGain();
    o.connect(g); g.connect(audioContext.destination);
    let freq = 440; let gain = 0.02;
    if(type==='move'){ freq = 880; gain = 0.02; }
    if(type==='capture'){ freq = 440; gain = 0.025; }
    if(type==='check'){ freq = 660; gain = 0.03; }
    if(type==='promo'){ freq = 1200; gain = 0.035; }
    o.frequency.value = freq; g.gain.value = gain;
    o.type = 'sine'; o.start();
    setTimeout(()=>{ o.stop(); }, 120);
  }catch(e){
    console.error("Erreur lors de la lecture du son:", e);
  }
}

const files = ['a','b','c','d','e','f','g','h'];
function inBoard(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function coordToIndex(coord){ 
  if(!/^([a-h])([1-8])$/.test(coord)) return null;
  const f = coord[0].charCodeAt(0)-97;
  const r = 8 - parseInt(coord[1],10);
  return {r,c:f};
}
function indexToCoord(r,c){ return files[c] + (8-r); }
function pieceColor(p){ if(!p) return null; return p===p.toUpperCase() ? 'w':'b'; }
function cloneBoard(b){ return b.map(row=>row.slice()); }
function clearLog(){ movesLog.innerHTML=''; }
function addLog(txt){
  const div = document.createElement('div');
  div.className = 'move-line';
  div.textContent = txt;
  movesLog.prepend(div);
  // Fait défiler le log pour voir le dernier coup
  movesLog.scrollTop = 0; 
}
function updateStatus(){ gameStatus.textContent = "Tour: " + (turn==='w' ? 'Blancs' : 'Noirs'); }
function updateCapturedDisplay() {
    capturedElem.textContent = `Capturées — Blancs: ${capturedPieces.w.length} | Noirs: ${capturedPieces.b.length}`;
}
function rebuildMovesLog() {
    clearLog();
    history.forEach(h => {
        addLog('Coup précédent (détails non sauvegardés)'); 
    });
    addLog('Historique du jeu rechargé.'); 
}

// --- SAVE / LOAD ---
function saveGame() {
  const gameState = {
    board: board, turn: turn, castleRights: castleRights,
    enPassant: enPassant, halfmoveClock: halfmoveClock,
    fullmoveNumber: fullmoveNumber, history: history, 
    capturedPieces: capturedPieces, orientation: orientation,
    currentTheme: 'neon', /* Thème forcé à néon pour la sauvegarde */
  };
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState));
    showFeedback("Partie sauvegardée.");
  } catch (e) { 
    console.error("❌ Erreur lors de la sauvegarde:", e); 
    showFeedback("Erreur de sauvegarde.", true);
  }
}

function loadGame() {
  try {
    const savedState = localStorage.getItem(STORAGE_KEY);
    if (!savedState) return false;
    
    const gameState = JSON.parse(savedState);
    board = gameState.board; turn = gameState.turn;
    castleRights = gameState.castleRights; enPassant = gameState.enPassant;
    halfmoveClock = gameState.halfmoveClock; fullmoveNumber = gameState.fullmoveNumber;
    history = gameState.history; capturedPieces = gameState.capturedPieces;
    orientation = gameState.orientation || 'white';
    
    // Le thème est toujours "neon" dans cette version
    document.body.className = `theme-neon`; 
    orientSelect.value = orientation;
    renderBoard(); updateStatus(); updateCapturedDisplay(); rebuildMovesLog();

    addLog("Partie chargée depuis la dernière sauvegarde.");
    showFeedback("Partie chargée.");
    return true;
  } catch (e) {
    console.error("❌ Erreur lors du chargement ou du parsing de la sauvegarde:", e);
    clearSavedGame(false);
    showFeedback("Erreur de chargement. Nouvelle partie démarrée.", true);
    return false;
  }
}

function clearSavedGame(showMsg = true) {
  try {
    localStorage.removeItem(STORAGE_KEY);
    if (showMsg) {
        showFeedback("Sauvegarde effacée.");
    }
  } catch (e) { 
    console.error("❌ Erreur lors de l'effacement de la sauvegarde:", e); 
    showFeedback("Erreur lors de l'effacement de la sauvegarde.", true);
  }
}

function init(resetSave = false){
  if (resetSave) { clearSavedGame(true); }
  if (!resetSave && loadGame()) { return; }

  board = cloneBoard(START_FEN); turn = 'w';
  castleRights = { wK:true, wQ:true, bK:true, bQ:true }; enPassant = null;
  halfmoveClock = 0; fullmoveNumber = 1; history = [];
  capturedPieces = { w:[], b:[] }; orientation = 'white';

  document.body.className = `theme-neon`; 
  orientSelect.value = orientation;
  
  updateStatus(); renderBoard(); clearLog(); updateCapturedDisplay();
  addLog("Partie démarrée — position initiale.");
  
  saveGame(); 
}

// --- RENDER ---
function renderBoard(){
  boardGrid.innerHTML = '';
  let rows = [...Array(8).keys()]; 
  let cols = [...Array(8).keys()];
  if(orientation === 'black'){ rows = rows.reverse(); cols = cols.reverse(); }

  for(let rIndex=0; rIndex<8; rIndex++){
    for(let cIndex=0; cIndex<8; cIndex++){
      const r = rows[rIndex];
      const c = cols[cIndex];
      const div = document.createElement('div');
      div.className = 'square ' + (((r+c)%2===0)?'light':'dark');
      div.dataset.r = r; div.dataset.c = c;
      div.id = `sq-${r}-${c}`;
      
      const coordSpan = document.createElement('div');
      coordSpan.style.position='absolute'; coordSpan.style.left='4px';
      coordSpan.style.bottom='2px'; coordSpan.style.fontSize='10px';
      coordSpan.style.opacity='0.4'; 
      coordSpan.textContent = indexToCoord(r,c);
      div.appendChild(coordSpan);

      boardGrid.appendChild(div);
    }
  }

  document.querySelectorAll('.piece').forEach(n => n.remove());

  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = board[r][c];
      if(p){
        const sq = document.getElementById(`sq-${r}-${c}`);
        if(sq){ 
          const pieceEl = document.createElement('div');
          pieceEl.className = 'piece';
          pieceEl.dataset.r = r; pieceEl.dataset.c = c;
          pieceEl.dataset.p = p;
          pieceEl.id = `pc-${r}-${c}`;
          pieceEl.textContent = PIECES_UNICODE[p];
          sq.appendChild(pieceEl);
        }
      }
    }
  }
}

// --- MOTEUR DE JEU LOGIC (Inchangé) ---
function generatePseudoLegalMoves(fromR, fromC){
  const p = board[fromR][fromC]; if(!p) return [];
  const color = pieceColor(p); const dir = (color==='w')?-1:1;
  const moves = []; const t = p.toLowerCase();

  // pawn
  if(t==='p'){
    const oneR = fromR + dir;
    if(inBoard(oneR,fromC) && !board[oneR][fromC]){
      if(oneR===0 || oneR===7){ moves.push({toR:oneR,toC:fromC,flags:{promotion:true}}); } 
      else moves.push({toR:oneR,toC:fromC,flags:{}});
      const startRank = (color==='w'?6:1);
      const twoR = fromR + dir*2;
      if(fromR===startRank && !board[twoR][fromC]){
        moves.push({toR:twoR,toC:fromC,flags:{doubleStep:true}});
      }
    }
    for(const dc of [-1,1]){
      const cr = fromR + dir, cc = fromC + dc;
      if(!inBoard(cr,cc)) continue;
      const target = board[cr][cc];
      if(target && pieceColor(target)!==color){
        if(cr===0 || cr===7){ moves.push({toR:cr,toC:cc,flags:{capture:true,promotion:true}}); } 
        else moves.push({toR:cr,toC:cc,flags:{capture:true}});
      }
      if(enPassant){
        const ep = coordToIndex(enPassant);
        if(ep && ep.r===cr && ep.c===cc){
          moves.push({toR:cr,toC:cc,flags:{enPassant:true}});
        }
      }
    }
    return moves;
  }

  // knight
  if(t==='n'){
    const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    deltas.forEach(d=>{
      const r=fromR+d[0], c=fromC+d[1];
      if(!inBoard(r,c)) return;
      const target = board[r][c];
      if(!target || pieceColor(target)!==pieceColor(p)){
        moves.push({toR:r,toC:c,flags: target ? {capture:true} : {}});
      }
    });
    return moves;
  }

  // bishop / rook / queen sliding
  const sliding = (t==='b' || t==='r' || t==='q');
  if(sliding){
    const dirs = [];
    if(t==='b' || t==='q') dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
    if(t==='r' || t==='q') dirs.push([-1,0],[1,0],[0,-1],[0,1]);
    dirs.forEach(d=>{
      let r = fromR + d[0], c = fromC + d[1];
      while(inBoard(r,c)){
        const target = board[r][c];
        if(!target){
          moves.push({toR:r,toC:c,flags:{}});
        } else {
          if(pieceColor(target)!==pieceColor(p)){ moves.push({toR:r,toC:c,flags:{capture:true}}); }
          break;
        }
        r+=d[0]; c+=d[1];
      }
    });
    return moves;
  }

  // king
  if(t==='k'){
    for(let dr=-1;dr<=1;dr++){
      for(let dc=-1;dc<=1;dc++){
        if(dr===0 && dc===0) continue;
        const r=fromR+dr, c=fromC+dc;
        if(!inBoard(r,c)) continue;
        const target = board[r][c];
        if(!target || pieceColor(target)!==pieceColor(p)){
          moves.push({toR:r,toC:c,flags: target ? {capture:true} : {}});
        }
      }
    }
    // castling (pseudo-legal check)
    const colorKey = pieceColor(p)==='w' ? 'w' : 'b';
    if(colorKey==='w'){
      if(fromR===7 && fromC===4){
        if(castleRights.wK && board[7][5]==='' && board[7][6]===''){ moves.push({toR:7,toC:6,flags:{castle:'K'}}); }
        if(castleRights.wQ && board[7][3]==='' && board[7][2]==='' && board[7][1]===''){ moves.push({toR:7,toC:2,flags:{castle:'Q'}}); }
      }
    } else {
      if(fromR===0 && fromC===4){
        if(castleRights.bK && board[0][5]==='' && board[0][6]===''){ moves.push({toR:0,toC:6,flags:{castle:'K'}}); }
        if(castleRights.bQ && board[0][3]==='' && board[0][2]==='' && board[0][1]===''){ moves.push({toR:0,toC:2,flags:{castle:'Q'}}); }
      }
    }
    return moves;
  }
  return moves;
}

function isSquareAttacked(r,c,attackerColor){
  for(let i=0;i<8;i++){
    for(let j=0;j<8;j++){
      const p = board[i][j];
      if(!p || pieceColor(p)!==attackerColor) continue;
      const t = p.toLowerCase();
      
      if(t==='p'){
        const dir = (attackerColor==='w')?-1:1;
        for(const dc of [-1,1]) if(i+dir===r && j+dc===c) return true;
        continue;
      }
      if(t==='n'){
        const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for(const d of deltas) if(i+d[0]===r && j+d[1]===c) return true;
        continue;
      }
      if(t==='b' || t==='q'){
        const dirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
        for(const d of dirs){
          let rr=i+d[0], cc=j+d[1];
          while(inBoard(rr,cc)){
            if(rr===r && cc===c) return true;
            if(board[rr][cc]) break;
            rr+=d[0]; cc+=d[1];
          }
        }
      }
      if(t==='r' || t==='q'){
        const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
        for(const d of dirs){
          let rr=i+d[0], cc=j+d[1];
          while(inBoard(rr,cc)){
            if(rr===r && cc===c) return true;
            if(board[rr][cc]) break;
            rr+=d[0]; cc+=d[1];
          }
        }
      }
      if(t==='k'){
        for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++) if(i+dr===r && j+dc===c) return true;
      }
    }
  }
  return false;
}

function findKing(color){
  for(let r=0;r<8;r++) for(let c=0;c<8;c++){
    const p = board[r][c];
    if(p && p.toLowerCase()==='k' && pieceColor(p)===color) return {r,c};
  }
  return null;
}

function isInCheck(color){
  const k = findKing(color);
  if(!k) return false; 
  return isSquareAttacked(k.r,k.c, color==='w' ? 'b' : 'w');
}

function isLegalMove(fr,fc,tr,tc,flags={},promo=null){
  const pseudo = generatePseudoLegalMoves(fr,fc);
  const found = pseudo.find(m => m.toR===tr && m.toC===tc && 
    ((m.flags.castle && flags.castle) || (!m.flags.castle && !flags.castle))
    && ((m.flags.promotion && flags.promotion) || (!m.flags.promotion && !flags.promotion))
    && ((m.flags.enPassant && flags.enPassant) || (!m.flags.enPassant && !flags.enPassant))
  );
  if(!found) return false;

  const originalBoard = board;
  const tempBoard = cloneBoard(board);
  
  // SIMULATION
  const piece = tempBoard[fr][fc];
  
  if(flags.enPassant){
    tempBoard[fr][tc] = '';
  }
  
  tempBoard[tr][tc] = (flags.promotion && promo) ? (pieceColor(piece)==='w' ? promo.toUpperCase() : promo.toLowerCase()) : piece;
  tempBoard[fr][fc] = '';

  // Simulate Castling Rook Move
  if(flags.castle){
    const r = (pieceColor(piece)==='w') ? 7 : 0;
    if(flags.castle==='K'){ // Kingside
      tempBoard[r][5] = tempBoard[r][7]; tempBoard[r][7] = '';
    } else { // Queenside
      tempBoard[r][3] = tempBoard[r][0]; tempBoard[r][0] = '';
    }
  }

  // Check if own king is now in check on the simulated board
  board = tempBoard;
  const stillInCheck = isInCheck(pieceColor(piece));
  board = originalBoard; // Restore main board

  return !stillInCheck;
}

function isCheckmate(color){
  if(!isInCheck(color)) return false;
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const p = board[r][c];
      if(!p || pieceColor(p)!==color) continue;
      const pseudo = generatePseudoLegalMoves(r,c);
      for(const m of pseudo){
        const flags = Object.assign({},m.flags||{});
        const promos = (m.flags.promotion ? ['Q','R','B','N'] : [null]);
        for(const promo of promos){
          if(isLegalMove(r,c,m.toR,m.toC,flags,promo)) return false;
        }
      }
    }
  }
  return true;
}

function attemptMove(fr,fc,tr,tc,promo=null){
  const piece = board[fr][fc];
  if(!piece){ addLog("Aucune pièce sur la case " + indexToCoord(fr,fc)); return false; }
  if(pieceColor(piece)!== (turn==='w'?'w':'b')){ addLog("Ce n'est pas ton tour."); return false; }

  const pseudo = generatePseudoLegalMoves(fr,fc);
  let chosen = null;
  for(const m of pseudo){
    if(m.toR===tr && m.toC===tc){ chosen = m; break; }
  }
  if(!chosen){ addLog("Coup non autorisé par le mouvement de la pièce."); return false; }

  const flags = Object.assign({}, chosen.flags || {});
  if(flags.promotion && !promo){
    showPromotionModal((chosenPromo)=>{ attemptMove(fr,fc,tr,tc,chosenPromo); });
    return 'pending';
  }

  const legal = isLegalMove(fr,fc,tr,tc,flags,promo);
  if(!legal){ addLog("Coup illégal : expose le roi à l'échec."); return false; }

  // Record history
  history.push({
    board: cloneBoard(board), turn, castleRights: Object.assign({},castleRights),
    enPassant, halfmoveClock, fullmoveNumber,
    capturedPieces: { w: capturedPieces.w.slice(), b: capturedPieces.b.slice() }
  });

  // EXECUTE MOVE
  let captured = null;
  if(flags.enPassant){
    const capR = fr; const capC = tc;
    captured = board[capR][capC];
    board[capR][tc] = ''; 
  } else {
    captured = board[tr][tc];
  }

  board[tr][tc] = (flags.promotion && promo) ? ((pieceColor(piece)==='w')?promo.toUpperCase():promo.toLowerCase()) : piece;
  board[fr][fc] = '';

  // Castling rook move
  if(flags.castle){
    const r = (pieceColor(piece)==='w') ? 7 : 0;
    if(flags.castle==='K'){ board[r][5] = board[r][7]; board[r][7]=''; }
    else { board[r][3]=board[r][0]; board[r][0]=''; }
  }

  // Update enPassant target
  if(piece.toLowerCase()==='p' && Math.abs(tr-fr)===2){
    enPassant = indexToCoord((fr+tr)/2, fc);
  } else { enPassant = null; }

  // Update castle rights
  if(piece.toLowerCase()==='k'){
    if(pieceColor(piece)==='w'){ castleRights.wK=false; castleRights.wQ=false; }
    else { castleRights.bK=false; castleRights.bQ=false; }
  }
  if(piece.toLowerCase()==='r'){
    if(pieceColor(piece)==='w'){ 
        if(fc===0) castleRights.wQ=false;
        if(fc===7) castleRights.wK=false;
    } else {
        if(fc===0) castleRights.bQ=false;
        if(fc===7) castleRights.bK=false;
    }
  }

  // Si une tour est capturée
  if(tr===7 && tc===0 && captured){ castleRights.wQ=false; }
  if(tr===7 && tc===7 && captured){ castleRights.wK=false; }
  if(tr===0 && tc===0 && captured){ castleRights.bQ=false; }
  if(tr===0 && tc===7 && captured){ castleRights.bK=false; }

  if(piece.toLowerCase()==='p' || captured || flags.enPassant) halfmoveClock = 0; else halfmoveClock++;
  if(turn==='b') fullmoveNumber++;

  if(captured || flags.enPassant) {
    if(flags.enPassant){
      const capPawn = pieceColor(piece)==='w' ? 'p' : 'P';
      capturedPieces[pieceColor(capPawn)].push(capPawn);
    } else if (captured) {
        capturedPieces[pieceColor(captured)].push(captured);
    }
  }

  renderBoard();
  highlightLastMove(fr,fc,tr,tc);
  if(captured || flags.enPassant || flags.castle) playSimple('capture'); else playSimple('move'); 

  const moveNotation = indexToCoord(fr,fc) + (captured || flags.enPassant ? 'x' : '-') + indexToCoord(tr,tc) + (flags.promotion ? ('=' + (promo?promo:'Q')) : '');
  addLog((turn==='w' ? (Math.ceil(fullmoveNumber-1)+'. ') : '') + moveNotation);

  turn = (turn==='w') ? 'b' : 'w';
  updateStatus();

  const opponent = turn==='w' ? 'w' : 'b';
  if(isInCheck(opponent==='w'?'w':'b')){
    addLog("Échec à " + (opponent==='w'?'Blancs':'Noirs') + " !");
    playSimple('check');
    if(isCheckmate(opponent==='w'?'w':'b')){
      addLog("Échec et mat — " + (turn==='w'?'Blancs':'Noirs') + " gagne !");
      gameStatus.textContent = "Partie terminée — " + (turn==='w'?'Blancs':'Noirs') + " gagne";
    }
  }

  updateCapturedDisplay();
  saveGame(); 
  return true;
}

function applyMoveNotation(notation){
  notation = notation.replace(/\s+/g,'').trim();
  const m = notation.match(/^([a-h][1-8])[x-]?([a-h][1-8])(?:=?([QRBNqrbn]))?$/);
  if(!m){ addLog("Notation invalide. Format attendu: e2-e4, e4xd5 ou e7e8=Q"); return false; }
  const from = m[1], to = m[2], promo = m[3] ? m[3].toUpperCase() : null;
  const f = coordToIndex(from), t = coordToIndex(to);
  if(!f || !t){ addLog("Coordonnées invalides."); return false; }
  return attemptMove(f.r,f.c,t.r,t.c,promo);
}

function highlightLastMove(fr,fc,tr,tc){
  document.querySelectorAll('.square').forEach(s=>s.classList.remove('last-move'));
  const sq1 = document.getElementById(`sq-${fr}-${fc}`);
  const sq2 = document.getElementById(`sq-${tr}-${tc}`);
  if(sq1) sq1.classList.add('last-move');
  if(sq2) sq2.classList.add('last-move');
}

function showPromotionModal(callback){
  promoModal.style.display = 'block';
  const currentTurn = turn;
  const pieceColorCode = currentTurn === 'w' ? '' : 'l'; 

  promOptions.querySelectorAll('button').forEach(btn => {
      const pieceType = btn.dataset.piece;
      btn.textContent = PIECES_UNICODE[pieceType + (currentTurn === 'w' ? 'W' : 'q')];
  });
  
  function onChoose(e){
    const p = e.target.dataset.piece;
    if(!p) return;
    promoModal.style.display = 'none';
    promOptions.removeEventListener('click', onChoose);
    playSimple('promo');
    callback(p);
  }
  promOptions.addEventListener('click', onChoose);
}


// --- UI HANDLERS (Gestion des clics) ---
let clickState = {src:null, highlights:[]};
function clearHighlights(){
  document.querySelectorAll('.square').forEach(s=>s.classList.remove('highlight'));
  clickState.highlights = [];
}
boardGrid.addEventListener('click', (e)=>{
  if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume().catch(e => console.error("Échec de la reprise de l'AudioContext:", e));
  }
  
  let sq = e.target;
  while(sq && !sq.classList.contains('square')) sq = sq.parentElement;
  if(!sq) return;
  const r = parseInt(sq.dataset.r,10), c = parseInt(sq.dataset.c,10);
  const p = board[r][c];

  if(clickState.src && clickState.highlights.some(h => h.r === r && h.c === c)){
    const fr = clickState.src.r, fc = clickState.src.c;
    attemptMove(fr,fc,r,c,null);
    clearHighlights();
    clickState.src=null;
  } else {
    clearHighlights();
    clickState.src=null;
    if(p && pieceColor(p)===(turn==='w'?'w':'b')){
      clickState.src = {r,c};
      const pseudo = generatePseudoLegalMoves(r,c);
      const legalTargets = [];
      for(const m of pseudo){
        const flags = Object.assign({},m.flags||{});
        const promos = (m.flags.promotion ? ['Q','R','B','N'] : [null]);
        for(const promo of promos){
            if(isLegalMove(r,c,m.toR,m.toC,flags, promo ? 'Q' : null)){
                legalTargets.push({r:m.toR,c:m.toC,flags:m.flags});
                break;
            }
        }
      }
      for(const t of legalTargets){
        const el = document.getElementById(`sq-${t.r}-${t.c}`);
        if(el) el.classList.add('highlight');
        clickState.highlights.push({r:t.r,c:t.c});
      }
      sq.classList.add('highlight');
      clickState.highlights.push({r,c});
    }
  }
});

// Event Listeners
sendMoveBtn.addEventListener('click', ()=>{ 
  const val = moveInput.value.trim();
  if(!val) return;
  const res = applyMoveNotation(val);
  if(res!=='pending') moveInput.value='';
});
moveInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') sendMoveBtn.click(); });

/* themeSelect.addEventListener('change', (e)=>{
  const newTheme = e.target.value;
  document.body.className = `theme-${newTheme}`;
  currentTheme = newTheme;
  saveGame(); 
}); */ // SUPPRIMÉ

resetBtn.addEventListener('click', ()=>{ 
    if(confirm("Êtes-vous sûr de vouloir commencer une nouvelle partie et effacer la sauvegarde actuelle ?")) {
        init(true); 
    }
});

undoBtn.addEventListener('click', ()=>{
  if(history.length===0) return;
  const last = history.pop(); 
  board = last.board; turn = last.turn;
  castleRights = last.castleRights; enPassant = last.enPassant;
  halfmoveClock = last.halfmoveClock; fullmoveNumber = last.fullmoveNumber;
  capturedPieces = last.capturedPieces;
  renderBoard(); updateStatus(); updateCapturedDisplay();
  addLog("Coup annulé");
  saveGame(); 
});
orientSelect.addEventListener('change',(e)=>{ 
    orientation = e.target.value==='white' ? 'white' : 'black'; 
    renderBoard(); 
    saveGame(); 
});
flipBoardBtn.addEventListener('click', ()=>{ 
    orientation = (orientation==='white') ? 'black' : 'white'; 
    orientSelect.value = orientation;
    renderBoard(); 
    saveGame(); 
});
toggleSoundBtn.addEventListener('click', ()=>{ 
    soundEnabled = !soundEnabled; 
    addLog('Sons ' + (soundEnabled?'activés':'désactivés')); 
});
exportPgn.addEventListener('click', ()=>{
  let pgn = '';
  const lines = Array.from(movesLog.querySelectorAll('.move-line')).reverse().map(n=>n.textContent);
  pgn = lines.join(' ');
  const blob = new Blob([pgn], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'game.pgn'; a.click();
  URL.revokeObjectURL(url);
  addLog("PGN exporté.");
});

init(); 
</script>
</body>
</html>
